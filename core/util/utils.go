/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"io"
	"math/big"
	"strings"
	"time"

	"github.com/golang/protobuf/ptypes/timestamp"
	"golang.org/x/crypto/sha3"
)

type alg struct {
	hashFun func([]byte) string
}

const defaultAlg = "sha256"

var availableIDgenAlgs = map[string]alg{
	defaultAlg: alg{GenerateIDfromTxSHAHash},
}

// ComputeCryptoHash should be used in openchain code so that we can change the actual algo used for crypto-hash at one place
//@@ ComputeCryptoHash : 해쉬알고리즘을 추후에 변경하게 되면 이 함수만 변경하면 됨.
//@@ 외부에서 해쉬 알고리즘을 콜링하는 진입 함수? 현재는 sha256을 채택한 상태
func ComputeCryptoHash(data []byte) (hash []byte) {
	hash = make([]byte, 64)
	sha3.ShakeSum256(hash, data)
	return
}

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
//@@ GenerateBytesUUID : UUID(universally unique identifier)를 리턴함. (UUID: 네트워크 상에서 서로 모르는 개체들은 식별하기 위한 ID)
//@@ RFC4122 : A Univerally Unique Identifier URN Namespace
//@@ 128 randomly-generated bits with six bits at certain positions set to particular values
//@@ 예시 : 6948DF80-14BD-4E04-8842-7668D9C001F5
//@@ byte array type

func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateIntUUID returns a UUID based on RFC 4122 returning a big.Int
//@@ big.Int 타입의 UUID 리턴
func GenerateIntUUID() *big.Int {
	uuid := GenerateBytesUUID()
	z := big.NewInt(0)
	return z.SetBytes(uuid)
}

// GenerateUUID returns a UUID based on RFC 4122
//@@ string 타입의 UUID 리턴
func GenerateUUID() string {
	uuid := GenerateBytesUUID()
	return idBytesToStr(uuid)
}

// CreateUtcTimestamp returns a google/protobuf/Timestamp in UTC
//@@ CreateUtcTimestamp : google/protobuf/Timestamp에서 정의하는 UTC를 리턴(협정세계시)
func CreateUtcTimestamp() *timestamp.Timestamp {
	now := time.Now().UTC()
	secs := now.Unix()
	nanos := int32(now.UnixNano() - (secs * 1000000000))
	return &(timestamp.Timestamp{Seconds: secs, Nanos: nanos})
}

//GenerateHashFromSignature returns a hash of the combined parameters
//@@ 결합된 파라미터들의 해쉬값을 리턴. -> sha256적용한 ComputeCryptoHash를 call
func GenerateHashFromSignature(path string, args []byte) []byte {
	return ComputeCryptoHash(args)
}

// GenerateIDfromTxSHAHash generates SHA256 hash using Tx payload
//@@ 트랜잭션의 페이로드에 대한 SHA256 hash 적용 결과를 리턴.
func GenerateIDfromTxSHAHash(payload []byte) string {
	return fmt.Sprintf("%x", sha256.Sum256(payload))
}

// GenerateIDWithAlg generates an ID using a custom algorithm
//@@ 사용자가 정의한 알고리즘에 따라 ID를 생성
func GenerateIDWithAlg(customIDgenAlg string, payload []byte) (string, error) {
	if customIDgenAlg == "" {
		customIDgenAlg = defaultAlg
	}
	var alg = availableIDgenAlgs[customIDgenAlg]
	if alg.hashFun != nil {
		return alg.hashFun(payload), nil
	}
	return "", fmt.Errorf("Wrong ID generation algorithm was given: %s", customIDgenAlg)
}

//@@ byte 형태의 ID를 string 형태로 변환하여 리턴.
func idBytesToStr(id []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", id[0:4], id[4:6], id[6:8], id[8:10], id[10:])
}

// FindMissingElements identifies the elements of the first slice that are not present in the second
// The second slice is expected to be a subset of the first slice
//@@ 두번째 슬라이스에 나타나지 않은 첫번째 슬라이스의 엘리먼트를 찾음.
//@@ 두번째 슬라이스는 첫번째 슬라이스의 subset임.
//@@ 첫번째와 두번째 슬라이스에 중복되어 있지 않은 엘리먼트를 찾음
func FindMissingElements(all []string, some []string) (delta []string) {
all:
	for _, v1 := range all {
		for _, v2 := range some {
			if strings.Compare(v1, v2) == 0 {
				continue all
			}
		}
		delta = append(delta, v1)
	}
	return
}

//@@ 체인코드의 입력 인자들을 byte array로 변환
func ToChaincodeArgs(args ...string) [][]byte {
	bargs := make([][]byte, len(args))
	for i, arg := range args {
		bargs[i] = []byte(arg)
	}
	return bargs
}

func ArrayToChaincodeArgs(args []string) [][]byte {
	bargs := make([][]byte, len(args))
	for i, arg := range args {
		bargs[i] = []byte(arg)
	}
	return bargs
}
